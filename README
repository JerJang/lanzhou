
1. 概述

   1.1) 数据文件的格式请参考《 RIBLL1 实验室VME获取系统使用手册 V1.02 》,第八节；

   1.2) 程序采用面向过程方式，为了简便，程序使用了 7 个全局变量，如果要对程序进行修改，需要特别注意不要与全局变量冲突；程序启动后，可以全程无人值守运行；

   1.3) 程序采用两个线程，一个”主线程“用于从磁盘读入数据文件，另一个”解码线程“用于对数据文件进行解码。如果需要将解码后的数据以新的格式存储，可将输出的代码放在解码线程中，后文对此将有更详细的说明；

   1.4) 程序读取数据文件目录下的所有数据文件，并对文件按照字符顺序进行排序，依次对每个文件进行解码操作。以上操作在 main 函数中实现，读取数据文件目录的操作在 scanDir 函数中实现；

   1.5) 定义：Event 是指数据文件中一个事件的数据。按顺序地，每一个 Event 包含一个 ”Event Counter“（EC）用于标识 Event 在当前文件中的序列号，占用 4 byte；一个 ”Header“ 占用 32 byte；和 ”Data from moduls“，用于记录来自各个插件的数据，占若干空间；每个 Event 的最后，还有一个 “Event Separator”（0xFFFFFFFF）符号，用于当前标识 Event 的结束。由于每个事件包含的信息多少不同，一个 Event 在文件中的长度是不确定的。这里定义一个 Event 是指从 EC 起，到其后的第一个 ”Event Separator“ 符号为止的文件部分（首尾两端均包含在内）；

   1.6) 关于在 1.5) 中提到的 Event Counter（EC），在每一个文件的第一个 Event 中被标识为 ”1“，在一个文件中，EC 是单调增加的，但是并不是连续的，所以不能用这个符号作为 Event 的计数器。值得注意的是，本程序中设置有全局变量 unsinged int EC，这个变量在每个文件中从 1 开始，单调增加，且是连续的；

   1.7) 关于在 1.5) 中提到的 Event Separator，在每个文件第一个 Event 之前也有一个该符号；

   1.6) 对于每个数据文件，首先提取数据文件开头的注释信息，并跳过第一个 Event Separator 符号，将文件指针置于文件所包含的第一个 Event 的第一个数据。然后即建立解码线程，并准备开始从磁盘读入数据。以上操作在 Decode 函数中；

   1.7) Loaduf 函数负责在主线程中从磁盘读入数据，数据文件按照指定地 Buffer 大小被一份一份地从磁盘读入内存，每一份称为一个 Buffer；

   1.8) 对于每个 Buffer，转由 DecodBuf 函数进行解码。这个函数是“解码线程”的入口函数。DecodeBuf 函数按照 “Event Separator” 将 Buffer 切割成 Event，将 Event 交给 EventDecode 函数进行解码；

   1.9) EventDecode 函数负责对每个 Event 进行解码操作，将 Event 头部的基本信息提取出来，再进一步将 Event 中的 Modul 依次切割出来，分别交给 Decode_v830ac 函数，Decode_v785n 函数，Decode_775n 函数，Decode_785 函数，Decode_792 函数进行处理；

   1.10) displayEvent 函数用于输出每个 Event，前面提到，如果需要将 Event 以某种格式存储到文件，可以修改这个函数实现。程序中已经在恰当的位置调用了 displayEvent 函数，如果需要，可以在程序头部添加宏定义 _OUTPUT_ ，使displayEvent 函数有效。


2. 程序的使用

   2.1) 使用前请根据本文档以及注释内容阅读程序；

   2.2) 出于简便考虑，程序中没有过多地考虑和设置对异常操作、非法操作的防范机制，所以使用中请尽量按照本文档进行操作；

   2.3) 配置：程序头部有宏定义作为配置参数使用；

===================================================================
   Macor	|    预设值	|              描述
====================================================================
 _DATA_DIRE	| "./source/"	|  数据文件所在的目录
--------------------------------------------------------------------
 _LOG_FILE	| "log"		|  日志文件的文件名
--------------------------------------------------------------------
 _MAX_FILE_NUM	| 10e7		|  最大允许的数据文件数量（不要太大）
--------------------------------------------------------------------
 _BUF_SIZE	| (25*1024*1024)|  数据缓存区的大小
--------------------------------------------------------------------
 _BUF_NUM	|  5		|  数据缓存区的数量
--------------------------------------------------------------------
 _THRE_WAIT	|  1000		|  线程等待时间
--------------------------------------------------------------------
 _TEST_		|		|  启用 “测试模式”
 		|		|  （此模式会极大消耗运行时间，故除了测试,
 		|		|  建议在正式运行中不要启用此模式）
--------------------------------------------------------------------
 _CONFIG_	|		|  启用 “配置模式”
--------------------------------------------------------------------
 _OUTPUT_	|		|  启用 “输出模式”
====================================================================

    2.4) 编译：
    编译时，需要加入 -lpthread 参数

         g++ -o decode decode.cpp -lpthread

    2.5) 运行测试；

    	 ./decode

    测试时，以 data.cpp 文件所在的目录为 “.” ，定义好数据文件所在的目录，建议可先用三五个数据文件做测试，定义 _TEST_ ,运行程序，程序将列出在数据文件目录下发现的所有数据文件，此时检查是否确实列出了全部文件。
    根据提示，按 ‘ENTER’ 进入数据解码，程序打印出一系列 Event，表示每个 Event 被解码。测试模式下，在每一个文件解码前和解码完成后，程序提示输入回车。正常运行时不会要求输入。
    测试时，可以启用 _DISPLAY_ ,在屏幕上打印每个 Event;

    2.6) 运行：

    	 ./decode

    运行程序时，请关闭 _TEST_ , _CONFIG_ ,将数据文件全部放在设定的目录下。程序运行期间不会要求任何输入，可无人值守运行，每解码一个文件，会在屏幕上打印一个信息，解码文件其间，除非遇到错误，否则程序不输出。
    如果在解码文件其间遇到错误，程序将视错误的严重情况，跳过当前 Event 、或者跳过当前 Buffer 、或者跳过当前文件，但是程序不会结束，最多放弃当前文件中剩余部分。
    Log 文件会记录运行过程中的重要节点，和全部错误信息，以便对之前由于出错而放弃的数据文件重新进行解码；



